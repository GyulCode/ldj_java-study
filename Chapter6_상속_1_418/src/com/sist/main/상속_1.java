package com.sist.main;
/*
 *    1) 네트워크 프로그램
 *    2) 데이터베이스 프로그램 (우리과정은 요거) 웹***
 *    ----------------------Spring
 *    DB는 데이터 저장 장소
 *    -------------------자바에서 읽기 (메모리 -> 제어)
 *    1. 메모리에 저장 : 변수 -> 제어 (제어문, 연산자)
 *    2. 데이터가 많은 경우
 *       = 같은 데이터형 : 배열
 *       = 다른 데이터형 : 클래스***
 *    3. 클래스
 *       = 클래스 정의 방법(객체지향프로그램 -> 한개의 클래스로 만드는 것이 아니라 클래스와 클래스의 연관관계) -> Spring (DI)
 *       							  								 행위자 : 웹(사용자, 관리자)
 *       ***접근지정어(권한)
 *       private : 자신의 클래스에서만 사용이 가능 -> 은닉화 (캡슐화)
 *                 -> 목적 : 데이터 보호
 *                 -> 변수(클래스의 속성)
 *                 -> private 데이터형 변수명
 *       default : 같은 패키지안에서만 사용이 가능
 *                 -> 윈도우, Thread(프로그램안에서 여러개 프로그램을 수행)
 *       protected : 같은 패키지안에서만 사용이 가능
 *                 -> 상속 받을 경우 다른 패키지에서 접근이 가능
 *                 -> 사용빈도가 거의 없다
 *                 -> 상속을 내리면 모든 변수, 메소드 사용이 가능
 *                    단 private 변수는 접근이 불가
 *                    ------------------------protected
 *       public : 모든 클래스에서 연결이 가능
 *                클래스 : 연관관계 -> 다른 클래스에서 접근이 가능
 *                생성자 : 다른 클래스에서 메모리 할당 후
 *                메소드 : 다른 클래스와 통신을 담당
 *       --> private / public
 *       -------------접근 지정어-----------------
 *       private < default < protected < public (***********)
 *       -> 오버라이딩 : 접근지정어의 확장은 가능(축소는 불가능)
 *       예) 한글 (브라우저 : C언어 --> char(ASC(아스키코드) 1byte) : 한글(UniCode(유니코드) 2byte)
 *       
 *       *메소드 오버라이딩시 확장자 역시 축소될 수 없다 부모클래스가 public잉 었다면 하위 역시 그 이상이거나 같아야한다
 *       상속 : 반복제거 extends 사용
 *       ***클래스의 구성 요소 : 벤치마킹 -> 요구사항 분석
 *       class ClassName
 *       {
 *          속성, 필드 멤버변수(캡슐화) -> 다른 클래스에서 사용이 가능하게 만든다
 *                  -------읽기/쓰기 메소드
 *                         ------ getter/setter -> 인스턴스 메소드
 *          공유변수 (static) : 패턴(싱글턴)
 *          	   ------메모리 공간이 한개
 *                 ------공유하는 데이터가 존재
 *          생성자
 *          1. 클래스명과 동일
 *          2. 멤버변수에 대한 초기화
 *          3. 생성가 없는 경우에는 자동으로 컴파일러가 기본생성자를 추가
 *          4. 모든 클래스는 생성자 1개 이상을 가지고 있다
 *          5. 생성자는 객체를 생성할때 호출되는 메소드
 *             사용법) new 생성자()
 *          6. 리턴형이 존재하지 않는다.
 *          7. 생성자는 필요시에는 여러개를 만들 수 있다
 *             오버로딩 지원한다(중복메소드 정의)
 *             한개의 메소드 이름으로 여러개 기능을 생성
 *             ***오버로딩 vs 오버라이딩(10 -> 9)
 *             		new		modify
 *             오버로딩 조건)
 *             1) 메소드명이 동일
 *             2) 한개의 클레스에서 만든다
 *             3) 매개변수의 갯수나 데이터형이 다르다
 *             4) 리턴형은관계 없다
 *             
 *             생성자는 초기화 담당
 *             ex)자동 로그인, 오라클 연결, 서버 연결 
 *             
 *             new (객체 생성바법)
 *             class A
 *             1) A a=new A()
 *             ----------------------
 *             2) A a=Class.forName("A").newInstnace()
 *             3) A a=A.newInstance()
 *             ------------------------리플렉션 (스프링 : 클래스 관리자)
 *             
 *             메소드 : 기능을 수행, 다른 클래스와 연결
 *             메소드 제작방법(형식)
 *             [접근 지정어(public)][제어어] 리턴형 메소드명(매개변수) -> 선언부
 *             {
 *                구현부
 *             }
 *             1. 선언부
 *                = 접근지정어 : public, default
 *                = 제어어 : static, final, abstract
 *                  static : public static
 *                  -> 객체마다 공통으로 사용되는 기능 (DB연결)
 *                  final : public final -> 오버라이딩이 안되는 상태
 *                          -> 수정이 불가능
 *                          -> Math, String, System -> 모든 메소드를 그대로 사용
 *                  abstract : 선언만 하는 메소드 -> 구현 (프로그램에 맞게 구현해서 사용)
 *                             하위 클래스에서 재정의
 *                             버튼 클릭
 *                             -> 추상클래스 / 인터페이스***
 *                                           -> 스프링의 기반 (결합성이 낮은 프로그램)
 *             리턴형 : 사용자 요청 처리한 결과값 한개만 사용이 가능
 *                    -> 여러개의 값이 있는경우
 *                       - 같은 데이터형 여러개 (배열) -> collection
 *                         배열(고정적) / 컬렉션(가변)
 *                       - 다른 데이터형 여러개 (클래스)
 *                         Member
 *                    -> 한개의 결과값 : 기본형, String
 *                    -> 결과값이 없는 경우 : 메소드 자체에서 처리 -> void
 *             매개변수 : 여러개 사용이 가능, 사용자 요청한값
 *                     매개변수는 최소화 시킨다/ 3개이상이면 배열, 클래스 사용
 *             구현부 : 변수가 선언이 되면 -> 지역변수(메소드 종료와 동시에 사라진다)
 *                    지역변수 : 초기화가 안됨(반드시 초기화후에 사용)
 *                    
 *          ***변수/메소드
 *          this : 클래스마다 this를 가지고 있다, 자신의 객체 주소를 가지고 있다.
 *          class A
 *          A a=new A()
 *          JVM : this=a;
 *          
 *          class A
 *          {
 *             A(){
 *             this가존재
 *             (this 생략됨).display()
 *          }
 *          void display()
 *          {
 *             this 사용이 가능
 *          }
 *          static void aaa()
 *          {
 *             this가 존재 하지 않는다.
 *             -> A a=new A();  -> 객체 생성후에 사용
 *          }    
 *          -> 멤버변수, 멤버메소드, 생성자 -> 클래스 소속
 *          A a=new A(); -> this
 *          A b=new A(); -> this
 *          ----------------------------
 *          this는 멤버변수와 지역변수의 구분
 *          class A
 *          {
 *             int age;
 *             public void setAge(int age)
 *             {
 *                this.age=age; //지역변수 우선순위라 멤버변수(전역변수)를 지칭할시 this사용
 *             }
 *          }
 *       }
 *        
 *       ---------------------------------------------------------------------------
 *       6장 시작
 *       -> 재사용 기법
 *       -> 수정, 추가
 *       -> 클래스 종류
 *       -------------
 *       견고한 프로그램을 만든다.
 *       -----------------
 *       재사용(상속, 포함) / 가독성(메소드) / 견고성(예외처리)
 *       194page
 *       자바 상속의 특징
 *       = 재사용 목적으로 사용한다(기존의 만들어진 클래스를 확장해서 사용)
 *          ***필요시에는 변경해서 사용이 가능(오버라이딩)
 *       = 반복 코딩을 제거할 수 있다.
 *       class A
 *       {~}
 *       class B extends A
 *       {~}
 *       = 기존에 만들어진 클래스를 확장해서 새로운 클래스를 만들어서 사용
 *       ex)
 *        class 게시판 
 *        {
 *           글쓰기 목록 상세보기 등등..
 *        }
 *        
 *        class 갤러리게시판 extends 게시판 
 *        {
 *           이미지 첨부 글쓰기 목록 상세보기 등등..  // 위와 동일한게 많음 extends 상속
 *        }
 *        단일 상속만 가능하다. 두개이상 받을 수 없음
 *        class B extend A,C  <- 이런거 불가
 *        class C extends B
 *        상속을 내리는 클래스 : 부모클래스, 슈퍼클래스, 베이스 클래스, 상위 클래스
 *        
 *        상속을 받는 클래스 : 자식클래스, 서브클래스, 파생클래스, 하위클래스
 *        
 *        상속이 있는 경우에는 클래스의 크기가 있다(형변환)(크기라는건 개념의 일반적인 크기를 뜻함)
 *        
 *        상속을 내리는 클래스 > 상속을 받는 클래스
 *        class Super
 *        class Sub extends Super
 *        ------------------------
 *        Sub sub=new Sub() <- 확장된 클래스 자체
 *        Super super=new Sub();  //하위 클래스를 이용해서 상위클래스 생성 <- 상속이 있을때는 가능
 *        ----------------------인터페이스/추상클래스
 *                              --------------미완성된 클래스
 *        Sub sub1=(Sub)Super; <- 큰걸로 받을라면 형변환후 사용 
 *        -----------------------------------
 *        
 *        일반적으로 
 *        클래스 = 생성자 동일
 *        -> 클래스와 생성자가 다른경우
 *        -> 클래스와 메소드 이용
 *        -----------------------인터페이스
 *        List list=new Arraylist()
 *        인터페이스는 new를 사용할 수 없음
 *        List list=new List(); //오류
 *        제네릭스<>
 *        컬렉션 배열대신 자료 모음
 *        
 *        A aaa=new B();
 *        aaa.a aaa.b aaa.c, aaa.display() = 2
 *        
 *                    -----
 *                    X사용불가
 *        변수는 A가 가지고 있는 변수만 사용가능 단 생성자는 B여서 초기화가 2로됨??
 *        
 *        
 *        
 *        
 *           
 *    
 */
/*
class Data
{
	private int a;

	public int getA() {
		return a;
	}

	public void setA(int a) {
		this.a = a;
	}
	
}

class Human
{
	Data d=new Data();
	public void getDate(int a) {
		d.setA(a);
	}
	
	public void print(){
		System.out.println("d.a="+d.getA());
	}
}
*/
class Super
{
	int a=10;
	int b=20;
	public void display() {
		System.out.println("Super 가 가지고 있는 display");
	}
}

//Super로부터 상속을 받는다 -> 예외조건) 생성자, 초기화 블럭, static(공유)
//private -> 상속은 가능 -> 접근이 불가능
//protected
//getter /setter


class Sub extends Super
{
	int c=30;
	public void display() {
		System.out.println("Sub가 가지고 있는 display");
	}
	
}

public class 상속_1 {

	public static void main(String[] args) {
		Sub sub=new Sub();
		Super sub1=new Sub();
//		System.out.println(sub1.c);
		sub1.display();
		
		
		// TODO Auto-generated method stub
		
		
		
		
		
		
		
		
		
//		Human h=new Human();
//		h.getDate(100);
//		h.print();
//		
//		Human h1=new Human();
//		h1.getDate(300);
//		h1.print();
//		
//		h.print();

	}

}
